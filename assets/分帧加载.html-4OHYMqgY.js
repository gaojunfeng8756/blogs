const e=JSON.parse('{"key":"v-507b6661","path":"/posts/cocosCreator2.x/%E5%88%86%E5%B8%A7%E5%8A%A0%E8%BD%BD.html","title":"分帧加载","lang":"zh-CN","frontmatter":{"title":"分帧加载","order":2,"description":"分帧加载 我们在生成item的时候，很容易造成页面动画卡顿，这个时候，我们需要考虑去分帧加载，可以参考以下代码 //初始化item initItem(index){ } /** * 实现分帧加载 */ async framingLoad(length: number) { await this.executePreFrame(this._getItemGenerator(length), 1); } private *_getItemGenerator(length: number) { for (let i = 0; i &lt; length; i++) { yield this.initItem(i); } } /** * 分帧执行 Generator 逻辑 * * @param generator 生成器 * @param duration 持续时间（ms） * 每次执行 Generator 的操作时，最长可持续执行时长。 * 假设值为8ms，那么表示1帧（总共16ms）下，分出8ms时间给此逻辑执行 */ private executePreFrame(generator: Generator, duration: number) { return new Promise((resolve, reject) =&gt; { let gen = generator; // 创建执行函数 let execute = () =&gt; { // 执行之前，先记录开始时间戳 let startTime = new Date().getTime(); // 然后一直从 Generator 中获取已经拆分好的代码段出来执行 for (let iter = gen.next(); ; iter = gen.next()) { // 判断是否已经执行完所有 Generator 的小代码段 // 如果是的话，那么就表示任务完成 if (iter == null || iter.done) { resolve(null); return; } // 每执行完一段小代码段，都检查一下是否 // 已经超过我们分配给本帧，这些小代码端的最大可执行时间 if (new Date().getTime() - startTime &gt; duration) { // 如果超过了，那么本帧就不在执行，开定时器，让下一帧再执行 this.scheduleOnce(() =&gt; { execute(); }); return; } } }; // 运行执行函数 execute(); }); }","head":[["meta",{"property":"og:url","content":"https://gaojunfeng8756.github.io/blogs/blogs/posts/cocosCreator2.x/%E5%88%86%E5%B8%A7%E5%8A%A0%E8%BD%BD.html"}],["meta",{"property":"og:site_name","content":"高乐高加奶"}],["meta",{"property":"og:title","content":"分帧加载"}],["meta",{"property":"og:description","content":"分帧加载 我们在生成item的时候，很容易造成页面动画卡顿，这个时候，我们需要考虑去分帧加载，可以参考以下代码 //初始化item initItem(index){ } /** * 实现分帧加载 */ async framingLoad(length: number) { await this.executePreFrame(this._getItemGenerator(length), 1); } private *_getItemGenerator(length: number) { for (let i = 0; i &lt; length; i++) { yield this.initItem(i); } } /** * 分帧执行 Generator 逻辑 * * @param generator 生成器 * @param duration 持续时间（ms） * 每次执行 Generator 的操作时，最长可持续执行时长。 * 假设值为8ms，那么表示1帧（总共16ms）下，分出8ms时间给此逻辑执行 */ private executePreFrame(generator: Generator, duration: number) { return new Promise((resolve, reject) =&gt; { let gen = generator; // 创建执行函数 let execute = () =&gt; { // 执行之前，先记录开始时间戳 let startTime = new Date().getTime(); // 然后一直从 Generator 中获取已经拆分好的代码段出来执行 for (let iter = gen.next(); ; iter = gen.next()) { // 判断是否已经执行完所有 Generator 的小代码段 // 如果是的话，那么就表示任务完成 if (iter == null || iter.done) { resolve(null); return; } // 每执行完一段小代码段，都检查一下是否 // 已经超过我们分配给本帧，这些小代码端的最大可执行时间 if (new Date().getTime() - startTime &gt; duration) { // 如果超过了，那么本帧就不在执行，开定时器，让下一帧再执行 this.scheduleOnce(() =&gt; { execute(); }); return; } } }; // 运行执行函数 execute(); }); }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-25T09:46:15.000Z"}],["meta",{"property":"article:author","content":"高乐高加奶"}],["meta",{"property":"article:modified_time","content":"2024-01-25T09:46:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分帧加载\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-25T09:46:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"高乐高加奶\\",\\"url\\":\\"hhttps://gaojunfeng8756.github.io/blogs/\\"}]}"]]},"headers":[{"level":2,"title":"分帧加载","slug":"分帧加载","link":"#分帧加载","children":[]}],"git":{"createdTime":1706173360000,"updatedTime":1706175975000,"contributors":[{"name":"嘻嘻","email":"1037775604@qq.com","commits":3}]},"readingTime":{"minutes":1.18,"words":354},"filePathRelative":"posts/cocosCreator2.x/分帧加载.md","localizedDate":"2024年1月25日","excerpt":"<h2> 分帧加载</h2>\\n<p>我们在生成item的时候，很容易造成页面动画卡顿，这个时候，我们需要考虑去分帧加载，可以参考以下代码</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>//初始化item\\ninitItem(index){\\n\\n}\\n  /**\\n * 实现分帧加载\\n */\\n    async framingLoad(length: number) {\\n        await this.executePreFrame(this._getItemGenerator(length), 1);\\n    }\\n\\n    private *_getItemGenerator(length: number) {\\n        for (let i = 0; i &lt; length; i++) {\\n            yield this.initItem(i);\\n        }\\n    }\\n\\n    /**\\n     * 分帧执行 Generator 逻辑\\n     *\\n     * @param generator 生成器\\n     * @param duration 持续时间（ms）\\n     *          每次执行 Generator 的操作时，最长可持续执行时长。\\n     *          假设值为8ms，那么表示1帧（总共16ms）下，分出8ms时间给此逻辑执行\\n     */\\n    private executePreFrame(generator: Generator, duration: number) {\\n        return new Promise((resolve, reject) =&gt; {\\n            let gen = generator;\\n            // 创建执行函数\\n            let execute = () =&gt; {\\n\\n                // 执行之前，先记录开始时间戳\\n                let startTime = new Date().getTime();\\n\\n                // 然后一直从 Generator 中获取已经拆分好的代码段出来执行\\n                for (let iter = gen.next(); ; iter = gen.next()) {\\n\\n                    // 判断是否已经执行完所有 Generator 的小代码段\\n                    // 如果是的话，那么就表示任务完成\\n                    if (iter == null || iter.done) {\\n                        resolve(null);\\n                        return;\\n                    }\\n\\n                    // 每执行完一段小代码段，都检查一下是否\\n                    // 已经超过我们分配给本帧，这些小代码端的最大可执行时间\\n                    if (new Date().getTime() - startTime &gt; duration) {\\n\\n                        // 如果超过了，那么本帧就不在执行，开定时器，让下一帧再执行\\n                        this.scheduleOnce(() =&gt; {\\n                            execute();\\n                        });\\n                        return;\\n                    }\\n                }\\n            };\\n\\n            // 运行执行函数\\n            execute();\\n        });\\n    }\\n\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
